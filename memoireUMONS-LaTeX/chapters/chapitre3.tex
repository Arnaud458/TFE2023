\chapter{Expérimentations}


\renewcommand{\leftmark}{EXPERIMENTATIONS}

\section{Matériel}

\subsection{radio logicielle}

La radio logicielle ($SDR$, pour $Software$-$Defined Radio$) est une technologie qui permet de mettre en œuvre des systèmes de radio à l'aide de logiciels plutôt que de matériel. 

Dans les systèmes de radio traditionnels, les différentes fonctions de la radio, comme l'accord sur une fréquence spécifique, la modulation et la démodulation du signal, et le filtrage du bruit, sont mises en œuvre à l'aide de composants matériels tels que des oscillateurs, des amplificateurs et des filtres. En revanche, les systèmes SDR utilisent des logiciels pour effectuer ces fonctions, ce qui les rends beaucoup plus flexible car chaque composante est reconfigurable. Les radios logicielle sotn capable d'opérer sur une large portée de fréquence, aussi bien très basse fréquence comme haute fréquence.
Les $SDR$ peuvent jouer le role d'éméteur ou de récepteur voir les deux.

\subsubsection{RTL SDR dvb T}

La première radio utilisée comme récepteur. possède différente composante :

rtl2832U: digitalise les signaux RF et les evnoie à l'ordinateur.
Tuner chip : le tuner permet d'ajuster la fréquence. Grace à ça la sdr peut couvrir une larger portée.
port usb : pour raccorder la sdr à l'ordinateur.

\subsubsection{RTL-SDR R820T2}



meilleure qualitée



\subsubsection{hackRf}

autre radio logicielle. plus (cher et) complète. meilleure qualité de signal que les rtl-sdr "classiques".

\subsection{Module d'émission Lora}

\subsubsection{module RN2483}

Le microchip RN2483 est un module de technologie spécifique à LoRa. Cet appareil permet de communiquer à longue portée et à faible coup grêve à l'utilisation de la modulation basé sur LoRa.

quelques spécificités du module :

technologie LoRa
faible puissance (ideale pour de l'iot car faible consommation)
fréquence à 433, 868 et 915MHz (regarder la régions adéquate)
AT command : configurable via un set de commande
compatible avec le protocole LoRaWAN pour établir ou rejoindre ce type de réseau.

fonctionne par entrée de commande (aucun retour écran donc aucune faute possible)

différentes commandes/ utilisation :

sys get ver : demande la verion du module, reçoit en réponse 
radio set (param) (value) : ajuste le paramètre pour l'adapter a la valeur souhaitée.

\subsubsection{pycom lopy}

besoin  d'un environement python , qqs configuration nécessaire.

\subsubsection{module arduino}

besoin d'un IDE arduino, possibilité de configurer une largeur de bande bien plus faible que pour les autre module, très pratique pour analyser le signal en détail.

\subsection{logiciel}

\subsubsection{gqrx}

logiciel open source d'analyse de fréquence radio pour les SDR.

installer gqrx via apt. (ubuntu)

sélectionner le périphérique pour analyse

\textcolor{red}{image choix périphérique}

visualisation du spectre

deux forme d'affichage,en spectre et en cascade.

L'affichage du spectre fournit une représentation graphique en temps réel du spectre RF sur une gamme de fréquences.
Il montre la puissance du signal de différentes fréquences sur une plage de fréquences spécifiée.
L'axe des x représente la fréquence, tandis que l'axe des y affiche la force du signal (mesurée en dB).

L'affichage en cascade est un spectrogramme qui visualise la force du signal au fil du temps.
Il montre une série d'instantanés de spectre empilés les uns sur les autres, où l'intensité de la couleur représente la force du signal.
Chaque ligne horizontale du tracé en cascade représente une vue du spectre capturée à un moment précis, créant ainsi un enregistrement historique de l'activité du signal.
L'axe vertical représente la fréquence et l'axe horizontal représente le temps.

\textcolor{red}{image affichage spectre}

configuration de la réception :

imput control (pas trop touché)

FFt settings : très important règle la ff size, le raffraichissemetn d'image. le laps de temps. l'averaging

Le paramètre Panadapter dB fait référence à l'échelle verticale dans la vue du spectre. Il représente la force du signal des fréquences radio reçues affichées sur l'axe vertical du graphique du spectre. Le réglage du paramètre Panadapter dB modifie l’échelle verticale de la force du signal affichée dans la vue du spectre.

Le paramètre Waterfall dB concerne l'intensité de la couleur ou l'ombrage des fréquences affichées dans le tracé en cascade.Le réglage du paramètre Waterfall dB modifie l'intensité utilisée pour afficher la force du signal dans le tracé en cascade, permettant ainsi d'ajuster le contraste ou la visibilité des signaux plus faibles ou plus forts.


\subsubsection{Universal radio hacker, URH}

logiciel open source. similaire à gqrx pour fonction d'analyse du signal. Il est possible de visualiser les signaux de manières analogique, démodulé, en spectrogramme ou en vue I/Q. Il est possible de découper les signaux, notamment pour supprimer les parties "vides" dans les enregistrements. Possibilité de sauvegarder des signaux enregistré dans des fichier. Urh supporte différents formats pour les signaux :

 \textit{.complex} files with complex64 samples (32 Bit float for I and Q, respectively). This is the default signal file format.
 
\textit{.complex16u} using two unsigned 8 Bit integers for I and Q

\textit{.complex16s} using two signed 8 Bit integers for I and Q

\textit{.complex32u} using two unsigned 16 Bit integers for I and Q (since v2.7)

\textit{.complex32s} using two signed 16 Bit integers for I and Q (since v2.7).

Il est également possible de lire des fichiers de données qui n'ont pas été enregistré avec URH tant qu'ils sont dans les formats supportés.

\section{Librairie python}

utilisation de python : pourquoi ?
librairie très utile dans le domaine comme NumPy, Pandas, Scikit-learn, PyCM et FiPy.
Librairie disponible pour les radio logiciel hackrf et rtlSDR.
Librairie compatible avec la sauvegarde et l'utilisation des données. Bonne documentation notament sur les formats des nombres complexes.
Capacités pour le machine learning. Utilisation de diverses algorithmes comme kmeans déja implémenté dans des librairies.
Intégration avec des modules, la librairie fipy gère l'un es modules utilisé pour les éxpérimentations.

numpy : pour complexe conjugué
matplotlib : pour les plot des diagrammes
datashader : pour la coloration du diagramme de constellations


\section{Géneration et réception d'un signal LoRa}

dans un premier temps les signaux sont généré manuellement sans automatisation, le but étant de reconnaitre et d'analyser la structure d'un signal Lora. le premier signal est généra via le module rn2483. La documentation est disponible au lien suivant (lien). Via python, il est possible d'utiliser la librairie \textit{Serial} pour se connecter au port usb reliant le module à l'ordinateur. Ensuite, via les différentes commandes, on configure le module en modifiant les paramètres suivant : 

\begin{itemize}
\item la modulation, en LoRa.
\item la fréquence. 868MHz, la fréquence de la bande ISM , la bande d'émission en Europe.
\item la largeur de bande. Dans un premier but de visualiation, on souhaiterai que le message soit le plus long possible dans le temps pour pouvir l'observer facilement. Ainsi la largeur de bande choisie est de 125Khz, ce qui est la plus petite possible valeur que permet le module.
\item la puissance du module, au maximum (14W).
\item le spreading factor. Même raisonement que pour la largeur de bande, on souhaite que le \textit{time on air} soit le plus long possible, donc la valeur la plus grande possible est choisie (SF = 12)
\item le coding rate. Il y a 4 valeur possible:s 4/5, 4/6, 4/7 and 4/8. Cela signifie que tout les 4 bits seront codé par 4, 5, 6, 7 ou 8 bits de transmissions en fonction de cette valeur. Plus la valeur st faible (la plus faible étant 4/8), plus le time on air sera élevé, car cela prend plus de temps pour transmettre le message.
\end{itemize}

Les commandes relatives à la configuration sont disponibles en annexes.
Une fois que le module est configurer, il faut paramètrer le recpeteur, la radio logicielle. La librairie pyrtlsdr permet de pouvoir configurer le récepteur, elle sera utlisée pour les expérmientations dans la section 3.4. Dans un premier temps, les logiciels comme gqrx ou urh permettent également de pouvoir configurer le récepteur. Leur utilisation a déja été décrite dans la section 3.1.3. Les paramètres à configurer sont les suivant : 

\begin{itemize}
\item la fréquence. La fréquece d'écoute. Idéalement la même fréquence de celle de l'émetteur (868MHz). Cependant celle ci sera légèrement décalée pour contrer un effet
\item le taux d'échantillonage. Il est possible de choisir la quantitté d'échantillons traitée chaque seconde. Un taux plus élevé donnera un signal plus complet. Le taux minimal ne doit jamais être inférieur à deux fois la largeur de bande. (Théorème de nyquist shannon : fe > 2fmax)
\item le gain. Dépendant de la qualité du signal il peut être nécessaire d'ajouter du gain, c'est à dire d'amplifier la force du signal. Un gain trop élevé peut saturer le signal, quand l'amplitude dépasse la portée du récepteur.
\end{itemize}

Une fois l'émetteur et le récepteur configuré, il est maintenant possible de visualiser des signaux Lora.

\subsection{analyse avec gqrx}



\subsection{analyse avec urh}

affichage du signal capturé, d'abords sous forme analogique, puis en spectrogramme.
Décomposition du signal, on observe des "chirps". En analogique, augmentation de la fréquence (unchirp) et diminution de la fréquence (downchirp). En spectrogramme, augmentation est plus visuelle encore, on voit de manière net les chirps.

Dans le signal, on reconnait donc le préambule du signal composé de 10 upchirps et 2 downchirps (selon la théorie).

Attention, la fréquence d'écoute des sdr ne doit pas être exactement à 868Mhz. En effet, voilà à quoi ressemble si la fréquence d'écout est la même que la fréquence d'émission. Il faut prendre en compte la largeur de bande du signal, dans le cas ou le singal a une largeur de bande de 125KHz, il faut décaler la fréquence d'écoute pour recentrer le signal, ainsi on évite d'avoir des fréquence qui sont interprétée comme "négatives" par URH. Dans la figure, la fréquence est décalé de 125/2 soit 867,935Mhz.

\subsection{automatisation du signal et preprocessing}

Dans un second temps, besoin d'automatiser la génération et l'enregistrement des signaux afin de pouvoir travailler avec un grand nombre d'échantillons. La librairie python pytlsdr permet de ne pas devoir passer par un logiciel comme urh pour sauvegarder les échantillons. La méthode d'enregistrement est la suivate :

\begin{itemize}
\item d'abords, configurer la module et la rtlsdr avec les différent paramètre
\item ensuite l'antenne commence a enregistrer. L'émetteur est informé que la radio logiciel est en écoute et envoie un signal. 
\item dès que la radio reçoit le signal, elle informe l'émetteur de se mettre en attente car le preprocessing commence.
\item Le signal reçu est découpé pour ne conserver que le preambule, et puis enregistrer dans un fichier.
\item dès que l'enregistrement est terminé, le cycle recommence.
\end{itemize}

la code source est disponible en annexe.


\section{Méthode "Constellation traces"}

objectif, identification du device via son frequecy offset.

selon l'article (citer article), possible de performer la méthode soit uniquement sur le  préambule, soit sur l'intégralité du singal. 

idée: le received singal contient le baseband singal ainsi qu'un rotation factor instable. pour pouvoir recover cette partie du signal, besoin d'effctuer une opération différentielle suivante : $$ x(t) . x(t+n) e -j2\pi on $$
apparation d'un nouveau rotation factor, mais stable. Besoin de trouver deux inconnue,\textit{delta f} et \textit{n}. n est le differential interval. il se calcule de la manière suivante : $$ Rs = BW / 2sf $$ 
$$ N = fs / Rs $$

delta f est la difference entre le transmitter carrier frequency et le receiver carrier frequecy.

application : récupérer les samples I/Q du signal n ayant au préalable "clean" le signal. utilisation d'un gradiant pour observer la dentsité sur le plot. noramlement des zones plus denses apparaissent.
coloration : utilisation de la librairie data shader. 


clustering, le but de conserver les parties les plus dense (95pourcent du point le plus dense) plot avec les différents appareils.
librairie panda et numpy. découpage en zones (bins?) sous forme d'une grille, calcul de nobre de points dans chaque zone, la zone avec le plus grand nombre de point sers de maximum. 
